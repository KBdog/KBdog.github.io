<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java常见容器的简介、排序与遍历</title>
    <url>/2021/04/20/collection/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看<a href="https://www.cyc2018.xyz/">csnotes</a>复习基础知识，正好写博客记录一下</p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/images_chapters/Collection.jpg" alt="Collection继承关系"></p>
<ol>
<li>Set</li>
</ol>
<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<ol start="2">
<li>Queue</li>
</ol>
<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<ol start="3">
<li>List</li>
</ol>
<ul>
<li>ArrayList：基于动态数组实现，支持随机访问，线程不安全。数组默认大小为10，每次扩容使用<code>grow()</code>方法扩容一半，也就是原数组大小的1.5倍。每次扩容时使用<code>Array.copyOf()</code>把原数组复制到新数组中。<br><img src="/images_chapters/ArrayList.jpg"></li>
<li>Vector：和 ArrayList 类似，虽然访问速度较慢，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<p>Collection各种集合的使用方式都差不多，以下用<code>ArrayList</code>作为例子<br><strong>使用collection类的sort()方法进行排序</strong><br>sort方法参数包含一个<code>List</code>和<code>Comparator</code>对象，<code>Comparator</code>中<code>compare</code>方法要指定排序规则，返回值若大于0则前者权重比后者大，将数组的前一个对象和后一个对象做交换，小于0则相反，等于0则按存入顺序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;User&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">       list.add(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">       list.add(<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;user3&quot;</span>));</span><br><span class="line">       <span class="comment">//list排序</span></span><br><span class="line">       <span class="comment">//list.sort(Comparator.comparing(User::getUid));</span></span><br><span class="line">       Collections.sort(list, <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o1.getUid()-o2.getUid();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用foreach和迭代器进行遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;user3&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">        <span class="comment">//list的遍历</span></span><br><span class="line">        <span class="comment">//foreach</span></span><br><span class="line">        <span class="keyword">for</span>(User user:list)&#123;</span><br><span class="line">            System.out.println(user.getUid()+<span class="string">&quot;,&quot;</span>+user.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//iterator</span></span><br><span class="line">        Iterator&lt;User&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            User next = iterator.next();</span><br><span class="line">            System.out.println(next.getUid()+<span class="string">&quot;,&quot;</span>+next.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/images_chapters/Map.jpg" alt="Collection继承关系"></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现，线程不安全。内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。在jdk1.8中，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。<br><img src="/images_chapters/HashMap.jpg"></li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<p>以<code>HashMap</code>作为例子进行<code>Map</code>集合的排序和遍历<br><strong>将Map转为List进行排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestHashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Map&lt;Integer,User&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="number">1</span>,<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">       map.put(<span class="number">2</span>,<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">       map.put(<span class="number">3</span>,<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;user3&quot;</span>));</span><br><span class="line">       <span class="comment">//转list排序:根据key值升序</span></span><br><span class="line">       ArrayList&lt;Map.Entry&lt;Integer, User&gt;&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">       entries.sort(Comparator.comparing(Map.Entry::getKey));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用foreach或迭代器进行遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestHashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Map&lt;Integer,User&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="number">1</span>,<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">       map.put(<span class="number">2</span>,<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">       map.put(<span class="number">3</span>,<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;user3&quot;</span>));</span><br><span class="line">       <span class="comment">//转list排序:根据key值升序</span></span><br><span class="line">       ArrayList&lt;Map.Entry&lt;Integer, User&gt;&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">       entries.sort(Comparator.comparing(Map.Entry::getKey));</span><br><span class="line">       <span class="comment">//foreach遍历</span></span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;Integer,User&gt; user:map.entrySet())&#123;</span><br><span class="line">   		System.out.println(user.getKey()+<span class="string">&quot;,&quot;</span>+user.getValue().getUsername());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//迭代器遍历</span></span><br><span class="line">       Iterator&lt;Map.Entry&lt;Integer, User&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           Map.Entry&lt;Integer, User&gt; userEntry = iterator.next();</span><br><span class="line">           System.out.println(userEntry.getKey()+<span class="string">&quot;,&quot;</span>+userEntry.getValue().getUsername());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决集合线程安全问题"><a href="#解决集合线程安全问题" class="headerlink" title="解决集合线程安全问题"></a>解决集合线程安全问题</h2><ol>
<li>最直接的方法是使用线程安全的集合，如<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、<code>ConcurrentLinkedQueue</code>、<code>ConcurrentLinkedDeque</code>等。</li>
<li>使用<code>Collections.synchronizedMap()</code>、<code>Collections.synchronizedList()</code>、<code>Collections.synchronizedCollection()</code>手动给线程不安全的集合加锁。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>collection</tag>
        <tag>map</tag>
        <tag>集合</tag>
        <tag>排序</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客</title>
    <url>/2021/01/17/hello-world/</url>
    <content><![CDATA[<h1 id="欢迎你陌生人"><a href="#欢迎你陌生人" class="headerlink" title="欢迎你陌生人"></a>欢迎你陌生人</h1><ul>
<li><a href="https://kbdog.github.io/">KBdog的个人博客</a></li>
<li><a href="https://github.com/KBdog">Github</a></li>
<li><a href="https://space.bilibili.com/3368545">Bilibili</a></li>
<li><a href="https://twitter.com/yu1246450339">Twitter</a></li>
</ul>
]]></content>
      <categories>
        <category>hello world</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（二）mybatis的动态sql以及主键回传、分页</title>
    <url>/2021/03/26/mybatis-2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>前几天写我的漫画存储项目时遇到个问题，因为设计的表结构主键自增的关系，在每次新插入漫画或章节信息时数据库会给每一个元组添加主键，每次我要按漫画信息-&gt;章节信息-&gt;图片信息的顺序插入时都要插入新数据后根据当前属性name值查一下id值才能根据id值进行下一步的插入，这样每次插入都多了一次查询操作，十分影响性能。后来通过<a href="https://mybatis.org/mybatis-3/java-api.html">mybatis的官方文档</a>找到了解决方案，mybatis的insert、update方法可以通过设置<code>useGeneratedKeys=true</code>和<code>keyProperty=&quot;id&quot;</code>实现主键回传功能然后在每次操作后返回操作元组的主键。这样一来每次操作完上一步的插入之后可以根据同一对象回传的id值进行下一步操作。</li>
<li>之前写批量的插入删除操作时都是对单条语句重复执行，极大地浪费性能，批量处理的语句可以通过动态sql的foreach来传值处理</li>
<li>查询分页通常分为物理分页和逻辑分页两种方法。物理分页就是在sql语句构建时候使用limit关键字进行查询，这一过程在数据库中已经完成。而逻辑分页通常是把所有结果集都查出来，然后在对应接口方法中添加指定了起始与长度的RowBounds对象，对所有数据再一次进行截获。所以，逻辑分页内存开销比较大,在数据量比较小的情况下效率比物理分页高;在数据量很大的情况下,内存开销过大,容易内存溢出。使用哪种分页要看具体情况来定夺。</li>
</ol>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol>
<li>主键回传</li>
<li>mapper的动态sql</li>
<li>物理分页和逻辑分页</li>
</ol>
<h3 id="主键回传"><a href="#主键回传" class="headerlink" title="主键回传"></a>主键回传</h3><p>mapper文件方式：给insert或update方法添加属性值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--插入漫画--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertComic&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.kbcomic.entity.Comic&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;comic_id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;comicId&quot;</span>&gt;</span></span><br><span class="line">        insert into all_comic 		  (comic_name,comic_description,comic_cover,create_time,update_time)</span><br><span class="line">        values (&#x27;$&#123;comicName&#125;&#x27;,&#x27;$&#123;comicDescription&#125;&#x27;,&#x27;$&#123;comicCover&#125;&#x27;,&#x27;$&#123;createTime&#125;&#x27;,&#x27;$&#123;updateTime&#125;&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注解形式：在mapper接口对应方法上添加@Options注解并设属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入漫画</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true,keyProperty = &quot;comicId&quot;)</span></span><br><span class="line"><span class="function">Integer <span class="title">insertComic</span><span class="params">(Comic comic)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><ul>
<li>if</li>
<li>choose(when，otherwise)</li>
<li>foreach</li>
</ul>
<p>下面的大部分内容直接搬mybatis文档= =（懒得自己再写一遍）</p>
<p><strong>if</strong><br>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果</p>
<p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>choose、when、otherwise</strong><br>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>foreach</strong><br>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符<br>使用我自己项目的例子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--批量删除磁力--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;batchDeleteMagnet&quot;</span>&gt;</span></span><br><span class="line">        delete from magnet</span><br><span class="line">        where name in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;nameList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;magnetName&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;magnetName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假如namelist列表的值为(1,2,3)则该语句相当于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;batchDeleteMagnet&quot;</span>&gt;</span></span><br><span class="line">        delete from magnet</span><br><span class="line">        where name in</span><br><span class="line">        (1,2,3)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即是把name值为1，2，3的元组都删除，这个sql优化比之前重复操作同一条删除语句要更方便高效</p>
<p><strong>script</strong><br>要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;update Author&quot;,</span></span><br><span class="line"><span class="meta">      &quot;  &lt;set&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;  &lt;/set&gt;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;where id=#&#123;id&#125;&quot;,</span></span><br><span class="line"><span class="meta">      &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>物理分页例子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;pagingQueryMagnet&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.message.entity.Magnet&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from magnet</span><br><span class="line">        limit  #&#123;currentPage&#125;,#&#123;pageNum&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>逻辑分页例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from book&quot;)</span></span><br><span class="line"><span class="meta">@Results(id = &quot;book&quot;,value = &#123;</span></span><br><span class="line"><span class="meta">@Result(id = true,column = &quot;id&quot;,property = &quot;bookId&quot;),</span></span><br><span class="line"><span class="meta">@Result(column = &quot;bookname&quot;,property = &quot;bookName&quot;),</span></span><br><span class="line"><span class="meta">@Result(column = &quot;author&quot;,property = &quot;bookAuthor&quot;),</span></span><br><span class="line"><span class="meta">@Result(column = &quot;publicationdate&quot;,property = &quot;publicTime&quot;),</span></span><br><span class="line"><span class="meta">@Result(column = &quot;price&quot;,property = &quot;bookPrice&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;Book&gt;queryAll(RowBounds rowBounds);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从第一条开始查询两条数据</span></span><br><span class="line">RowBounds rowBounds=<span class="keyword">new</span> RowBounds(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">List&lt;Book&gt; books = mapper.queryAll(rowBounds);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>主键回传使用<code>useGeneratedKeys=true</code>和<code>keyProperty=&quot;id&quot;</code></li>
<li>动态sql在操作参数多的时候十分好用</li>
<li>使用哪种分页要根据实际情况来选择</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>动态sql</tag>
        <tag>数据库分页</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（一）mybatis的简单使用</title>
    <url>/2021/03/18/mybatis-1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个学期学校开始教javaee框架，虽说我之前已经稍微学习了解过ssm，但学习的过程以及内容挺碎片化的。现在再按学校教程顺序重新过一遍理论。从这篇博文开始记录一下学习ssm的整个过程。</p>
<h2 id="mybatis简介"><a href="#mybatis简介" class="headerlink" title="mybatis简介"></a>mybatis简介</h2><p>之前没有使用mybatis时通常都是使用jdbc的方法（主要的操作对象：Connection、Preparestatement、ResultSet）来操作数据库，每次执行sql操作都要频繁建立数据库连接，从而造成资源的浪费。mybatis是一种ORM框架，ORM框架可以完成对象模型和关系模型的映射。采用ORM框架后，应用程序不用再直接访问数据库，而是以面向对象的方法来操作持久化对象（PO），其通过面向对象的方法来代替程序操作底层SQL。简单理解就是mybatis不用执行jdbc方法中过多繁琐的操作，可以简化数据库操作。</p>
<h2 id="mybatis的配置"><a href="#mybatis的配置" class="headerlink" title="mybatis的配置"></a>mybatis的配置</h2><ol>
<li>如果在springboot项目中，只需在springboot整体的配置文件application.yml中配置即可</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">账号</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">密码</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=GMT</span> <span class="comment">#（如对应数据库有设置编码则需要说明characterEncoding）</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:映射文件目录mapping所在（如：classpath:mapping/*Mapper.xml）</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">数据库映射实体对象别名包（如：per.study.entity）</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果在其他项目中，则要额外编写配置文件（.xml），下面是一个简单的mybatis配置文件范例</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--environments中default元素指向默认数据源（此处数据源为id为mybatis的数据源）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mybatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给数据源定id值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mybatis&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--此处使用jdbc事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据库连接池参数--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--此处有三个参数可供选择，POOLED、UNPOOLED、JNDI--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--UNPOOLED每次被请求时都会打开和关闭，适用于没有性能要求的应用--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--POOLED避免了创建新连接实例所必须的初始化和认证时间，使用于Web应用的快速响应方式--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--JNDI这种数据源的实现是为了能和EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--驱动名（我使用的是mysql，对应以下驱动名）--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--mysql对应的url（如对应数据库有设置编码则需要说明characterEncoding）--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test-mybatis?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=GMT<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库账号密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapper映射文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;mapper.BookMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mapper的使用"><a href="#mapper的使用" class="headerlink" title="mapper的使用"></a>mapper的使用</h2><p>由于已经配置好配置文件，则我们可以开始关注具体业务的实现，不用再关心数据库连接的问题。</p>
<ol>
<li><p>mapper即是映射文件，通常命名为 实体名+Mapper.xml。mapper文件是sql语句的具体实现，增删改查的sql语句都会写在mapper里（非注解方式）。而对应的在程序里的接口类可以在mapper文件里指明来使用。</p>
</li>
<li><p>现在举个映射文件方式使用mapper的例子。（数据库all_comic表与Comic实体对应）</p>
</li>
</ol>
<p>首先建个实体类Comic</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用lombok可以自动生成set和get方法</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer comicId;</span><br><span class="line">    <span class="keyword">private</span> String comicName;</span><br><span class="line">    <span class="keyword">private</span> String comicDescription;</span><br><span class="line">    <span class="keyword">private</span> String comicCover;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其对应的接口dao层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComicMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有漫画</span></span><br><span class="line">    <span class="function">List&lt;Comic&gt; <span class="title">queryAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口所对应的mapper，mapper标签的namespace要指定接口文件的位置，resultMap是定义返回的结果集，增删改查的语句就不用多说了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.kbcomic.mapper.ComicMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;comic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.kbcomic.entity.Comic&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--column是数据库字段,property是实体属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicDescription&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_cover&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicCover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有漫画，id名要对应上接口方法名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;comic&quot;</span>&gt;</span></span><br><span class="line">        select * from all_comic</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据上面mapper文件和mapper接口的映射，我们直接通过对象调用接口即可实现数据库操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先使用输入流读取配置文件</span></span><br><span class="line">InputStream inputStream= Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="comment">//使用mybatis四大组件中的构造器创建工厂</span></span><br><span class="line">SqlSessionFactoryBuilder builder=<span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"><span class="comment">//从输入流中获得配置文件</span></span><br><span class="line">SqlSessionFactory factory = builder.build(inputStream);</span><br><span class="line"><span class="comment">//从工厂中获得sqlsession</span></span><br><span class="line">SqlSession sqlSession = factory.openSession();</span><br><span class="line"><span class="comment">//获得session后可以对接mapper开始执行sql</span></span><br><span class="line">ComicMapper mapper = sqlSession.getMapper(ComicMapper.class);</span><br><span class="line"><span class="comment">//执行查询语句</span></span><br><span class="line">List&lt;Comic&gt; comics = mapper.queryAll();</span><br><span class="line"><span class="comment">//遍历集合打印</span></span><br><span class="line"><span class="keyword">for</span>(Comic comic:comics)&#123;</span><br><span class="line">    System.out.println(comic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>注解方式实现mapper</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComicMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有漫画</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from all_comic&quot;)</span></span><br><span class="line">    <span class="comment">//此处使用效果跟mapper文件中ResultMap一样，column指定数据库字段名，property指明对象实体属性</span></span><br><span class="line">    <span class="meta">@Results(id = &quot;comic&quot;,value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(id = true,column = &quot;comic_id&quot;,property = &quot;comicId&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;comic_name&quot;,property = &quot;comicName&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;comic_description&quot;,property = &quot;comicDescription&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;comic_cover&quot;,property = &quot;comicCover&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;update_time&quot;, property=&quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">List&lt;Comic&gt; <span class="title">queryAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见使用注解方式不用再编写mapper.xml文件，更进一步简化整个流程。这也是通常大众所使用的方式。</p>
<h2 id="mybatis中的缓存机制"><a href="#mybatis中的缓存机制" class="headerlink" title="mybatis中的缓存机制"></a>mybatis中的缓存机制</h2><p>mybatis缓存分为一级缓存和二级缓存，同时也可以配置关于缓存的设置。一级缓存是位于SqlSession上的缓存，二级缓存是在SqlSessionFactory上的缓存。通常情况下，mybatis会开启一级缓存，也就是处于SqlSession上的缓存，这个缓存不需要POJO对象可序列化。</p>
<ol>
<li>二级缓存的开启</li>
</ol>
<p>在mybatis的配置文件中的settings标签中添加二级缓存的开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（非注解方式）在mapper中添加二级缓存声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.kbcomic.mapper.ComicMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加二级缓存声明--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;comic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.kbcomic.entity.Comic&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--column是数据库字段,property是实体属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicDescription&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comic_cover&quot;</span> <span class="attr">property</span>=<span class="string">&quot;comicCover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有漫画，id名要对应上接口方法名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;comic&quot;</span>&gt;</span></span><br><span class="line">        select * from all_comic</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（注解方式）添加二级缓存，在mapper接口上添加@CacheNamespace(blocking = true)或对应方法添加option注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(blocking = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComicMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有漫画</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from all_comic&quot;)</span></span><br><span class="line">    <span class="comment">//此处使用效果跟mapper文件中ResultMap一样，column指定数据库字段名，property指明对象实体属性</span></span><br><span class="line">    <span class="meta">@Results(id = &quot;comic&quot;,value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(id = true,column = &quot;comic_id&quot;,property = &quot;comicId&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;comic_name&quot;,property = &quot;comicName&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;comic_description&quot;,property = &quot;comicDescription&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;comic_cover&quot;,property = &quot;comicCover&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;update_time&quot;, property=&quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="comment">//useCache=true启用二级缓存</span></span><br><span class="line">    <span class="meta">@Options(useCache = true)</span></span><br><span class="line">    <span class="function">List&lt;Comic&gt; <span class="title">queryAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>缓存方式的利弊</li>
</ol>
<p>利：开启缓存后，第一次查询会执行sql，第二次及以后的查询都会从缓存中读取数据。减少了访问数据库的次数，优化系统性能。<br>弊：开启缓存的弊端是数据没有实时性，当数据库中的数据一旦修改，查询的数据还是缓存中的数据没有实时性。</p>
<ol start="3">
<li>对于缓存方式的弊端，有如下解决方案</li>
</ol>
<p>（非注解方式）<br>①禁止缓存：在mapper文件select语句中设置useCache=”false”</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;comic&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        select * from all_comic</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>②清空缓存：在insert或update语句中设置flushCache=”true”</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateComic&quot;</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	update all_comic</span><br><span class="line">        set comic_description=#&#123;comic.comicDescription&#125;,comic_cover=#&#123;comic.comicCover&#125;,update_time=#&#123;comic.updateTime&#125;</span><br><span class="line">        where comic_id=#&#123;comicId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（注解方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在更新或插入时候刷新缓存</span></span><br><span class="line"><span class="meta">@Options(flushCache = Options.FlushCachePolicy.TRUE)</span></span><br><span class="line"><span class="function">Integer <span class="title">updateComic</span><span class="params">(Comic comic)</span></span>;</span><br><span class="line"><span class="comment">//在查询时禁止缓存</span></span><br><span class="line"><span class="meta">@Options(useCache = false)</span></span><br><span class="line">List&lt;Book&gt;queryAll();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>项目配置</tag>
      </tags>
  </entry>
  <entry>
    <title>记录从一月份以来的漫画爬虫学习</title>
    <url>/2021/03/15/crawler/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从上一年年末开始，我一直使用各种爬虫工具看漫画，这些爬虫工具引起了我浓厚的学习兴趣。于是脑海中产生了自己写爬虫工具的想法。后来我通过对tachiyomi，cimoc等开源项目以及各种博客的学习中了解到了基本的爬虫原理，然后着手实践起来。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ol>
<li>本人博文内容皆仅限用于学习和研究，部分敏感内容来源于互联网</li>
<li>如果侵犯了您的版权请通过<a href="mailto:1246450339@qq.com">我的邮箱</a>或<a href="https://space.bilibili.com/3368545">B站账号</a>与我获得联系，我会尽快删除相关内容</li>
</ol>
<h2 id="简单的漫画爬虫过程"><a href="#简单的漫画爬虫过程" class="headerlink" title="简单的漫画爬虫过程"></a>简单的漫画爬虫过程</h2><ol>
<li>使用抓包工具如<a href="https://www.charlesproxy.com/">Charles</a>等截获浏览器或app的http和https请求</li>
<li>获取并分析截获的api接口，从中提取关键信息（漫画的搜索关键字、章节、每张图片等在URL中的位置）</li>
<li>从漫画关键字搜索api中获取精准漫画信息</li>
<li>从漫画信息中提取漫画id或漫画路径</li>
<li>使用漫画id等关键信息访问章节api获取当前漫画所有章节</li>
<li>从单个章节中获取其所有图片列表</li>
<li>使用IO流下载图片</li>
</ol>
<h2 id="爬虫实践过程"><a href="#爬虫实践过程" class="headerlink" title="爬虫实践过程"></a>爬虫实践过程</h2><ol>
<li>第一个爬虫项目：<a href="https://github.com/KBdog/crawler-comic-dmzj">https://github.com/KBdog/crawler-comic-dmzj</a> ，完成时间：2021-01-26<br>这是我第一个爬虫项目，是通过分析dmzj网页版的标签来获取图片url下载，并不完全按以上顺序来进行。这个项目使用了selenium对网页进行模拟人工操作，通过ChromeDriver访问单点漫画首页获取所有章节标签链接，然后根据每个章节开多线程访问获得各章图片列表url。分析标签和下载使用了webmagic，在pipeline中使用io流对分析后的图片集合进行下载。（这次的项目还特意用javafx写了图形化界面，后面发现过于花里胡哨并不实用，因此在后续的爬虫项目中取消了写图形化界面的想法，直接改用命令行运行）</li>
<li>第二个爬虫项目：<a href="https://github.com/KBdog/crawler-comic-dmzj2">https://github.com/KBdog/crawler-comic-dmzj2</a>，完成时间：2021-02-01<br>分析dmzj的api接口一步步进行数据搜集<br>该项目参考了<a href="https://github.com/savvym/pydmzj.git">@SavvyM</a>大佬对dmzj的抓包接口，这也是我第一次了解到api接口。大佬给出的接口信息：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动漫之家搜索api:</span><br><span class="line">http:&#x2F;&#x2F;sacg.dmzj.com&#x2F;comicsum&#x2F;search.php?s&#x3D;$&#123;comic&#x2F;author&#125;</span><br><span class="line">小说详情api:  </span><br><span class="line">http:&#x2F;&#x2F;v2.api.dmzj.com&#x2F;novel&#x2F;$&#123;id&#125;.json (旧)  </span><br><span class="line">http:&#x2F;&#x2F;v3api.dmzj.com&#x2F;novel&#x2F;$&#123;id&#125;.json (新)  </span><br><span class="line">漫画详情api:  </span><br><span class="line">http:&#x2F;&#x2F;v2.api.dmzj.com&#x2F;comic&#x2F;$&#123;id&#125;.json (旧)  </span><br><span class="line">http:&#x2F;&#x2F;v3api.dmzj.com&#x2F;comic&#x2F;comic_$&#123;id&#125;.json(新)  </span><br><span class="line">漫画下载api:  </span><br><span class="line">https:&#x2F;&#x2F;imgzip.dmzj.com&#x2F;$&#123;first_character&#x2F;number&#125;&#x2F;$&#123;comic_id&#125;&#125;&#x2F;$&#123;chapter_id&#125;.zip  </span><br><span class="line">其中  </span><br><span class="line">$&#123;first_character&#x2F;number&#125;：漫画名称首字母或者数字  </span><br><span class="line">$&#123;comic_id&#125;:漫画id  </span><br><span class="line">$&#123;chapter_id&#125;:章节id  </span><br><span class="line">漫画章节信息api:  </span><br><span class="line">http:&#x2F;&#x2F;v3api.dmzj.com&#x2F;chapter&#x2F;$&#123;comic_id&#125;&#x2F;$&#123;chapter_id&#125;.json  </span><br><span class="line">漫画章节吐槽api:</span><br><span class="line">http:&#x2F;&#x2F;v3api.dmzj.com&#x2F;viewPoint&#x2F;0&#x2F;$&#123;comic_id&#125;&#x2F;$&#123;chapter_id&#125;.json </span><br></pre></td></tr></table></figure>
简单漫画的三要素为漫画简介、漫画章节、漫画图片，通过访问接口的信息分析得到，通常漫画的属性是按关键字、单漫画的id、单章节的id这个顺序来进行的。因此在代码中，我们可以通过解析接口返回的json数据来获得以上属性再逐步往下解析json最终使用io流下载图片。</li>
<li>第三个爬虫项目：<a href="https://github.com/KBdog/crawler-comic-copymanga">https://github.com/KBdog/crawler-comic-copymanga</a>，完成时间：2021-02-10<br>使用httpcanary抓包copymanga的api并下载其资源<br>由于各种各样的原因，dmzj的部分漫画隐藏了起来，通过抓包抓到的api仅仅能访问可供普通用户浏览的漫画，许多隐藏漫画都无法浏览下载，为了能浏览更多的漫画本人必须扩展漫画源。最后我选择了copymanga，其接口数据简单清晰。此次的项目中，我遇到了防盗链与代理的问题。通常网站都会做防盗链的处理，简单理解就是服务端会对你的请求头进行验证，其中referer的头信息如果没有包含要求的服务端要求的信息，则服务端会判断你访问该链接的方式并不是从他们网站跳转过去的，然后禁止访问。解决方案：在访问头信息中添加相应referer<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">&quot;Referer&quot;</span>,<span class="string">&quot;http://xxx.com/&quot;</span>);</span><br></pre></td></tr></table></figure>
然后就是代理问题，由于源站是域外的网站，访问不稳定且使用io流下载时使用的是tcp连接，影响更大，因此必须设置代理访问。这里使用快代理等免费代理即可解决。代理商提供的通常为Socket，在代码中建立连接时，使用代理连接服务商的socket进行代理访问即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>漫画</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（三）mybatis的关联映射</title>
    <url>/2021/03/30/mybatis-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在对数据库进行查询时，我们会遇到各种各样的查询需求，比如多表联结查询，这就需要了解一对一、一对多、多对多等概念。一对一顾名思义就是一个对象对应一个对象，比如一个班主任对应一个班级，这就是一对一，那么一对多可以理解为一个班级对应多个学生，在面向对象设计实体属性里就是班级类包含学生集合。下面用我的漫画查询作为例子来介绍这两种的关系。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>主要介绍的是一对多。在一部漫画中，通常关系都是这样的，一部漫画有多个章节，一个章节有多张图片，即是漫画：章节=1：n，漫画章节：章节图片=1：n。因此，在查询一部漫画所有内容时候我们可以通过先查漫画id获得漫画简介信息，然后通过漫画id获得章节列表，再根据每一个章节的id获得每一章的图片集合。下面分别使用了xml映射文件形式和注解形式实现这种关联查询方法。</p>
<p>首先要看看每个的实体类，不难发现都是一对多的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer comicId;</span><br><span class="line">    <span class="keyword">private</span> String comicName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ChapterModel&gt; chapterList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChapterModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer chapterId;</span><br><span class="line">    <span class="keyword">private</span> String chapterName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; picList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>映射文件形式</strong><br>这种形式我使用了左外连接的sql写法，在两个连接关节都让左表作为主表来列出所有集合元素</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--总信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.kbcomic.model.Message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;comicId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;comic_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;comicName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;comic_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--章节集合--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;chapterList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.kbcomic.model.ChapterModel&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;chapter_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;chapterId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;chapter_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;chapterName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--图片集合--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;picList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pic_url&quot;</span> <span class="attr">property</span>=<span class="string">&quot;picUrl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询总信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryMessageByComicId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;message&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">                all_comic.comic_id,</span><br><span class="line">                all_comic.comic_name,</span><br><span class="line">                all_chapter.chapter_id,</span><br><span class="line">                all_chapter.chapter_name,</span><br><span class="line">                all_pic.pic_url</span><br><span class="line">        from</span><br><span class="line">            all_comic</span><br><span class="line">        left join all_chapter on all_comic.comic_id=all_chapter.comic_id</span><br><span class="line">        left join all_pic on all_chapter.chapter_id=all_pic.chapter_id</span><br><span class="line">        where all_comic.comic_id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注解写法</strong><br>这种方式其实是对数据库查了三次再拼接起来最后的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注解方式实现一对多</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Select(&quot;select comic_id,comic_name from all_comic where comic_id=#&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(column = &quot;comic_id&quot;,property = &quot;comicId&quot;),</span></span><br><span class="line"><span class="meta">           @Result(column = &quot;comic_name&quot;,property = &quot;comicName&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;chapterList&quot;,column = &quot;comic_id&quot;,</span></span><br><span class="line"><span class="meta">                   many = @Many(select = &quot;com.example.kbcomic.mapper.MessageMapper.queryChapterList&quot;))</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function">Message <span class="title">queryMessage</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span>Integer comicId)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//根据漫画id查所有章节</span></span><br><span class="line">   <span class="meta">@Select(&quot;select chapter_id,chapter_name from all_chapter where comic_id=#&#123;comic_id&#125;&quot;)</span></span><br><span class="line">   <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(column = &quot;chapter_id&quot;,property = &quot;chapterId&quot;),</span></span><br><span class="line"><span class="meta">           @Result(column = &quot;chapter_name&quot;,property = &quot;chapterName&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;picList&quot;,column = &quot;chapter_id&quot;,</span></span><br><span class="line"><span class="meta">                   many = @Many(select = &quot;com.example.kbcomic.mapper.MessageMapper.queryPicList&quot;))</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   List&lt;ChapterModel&gt;queryChapterList(<span class="meta">@Param(&quot;comic_id&quot;)</span>Integer id);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//根据章节id查所有图片</span></span><br><span class="line">   <span class="meta">@Select(&quot;select pic_url from all_pic where chapter_id=#&#123;chapter_id&#125;&quot;)</span></span><br><span class="line">   List&lt;String&gt;queryPicList(<span class="meta">@Param(&quot;chapter_id&quot;)</span>Integer id);</span><br></pre></td></tr></table></figure>
<p>这两种写法得到的结果都是一样的。</p>
<h2 id="相关注释与标签的理解"><a href="#相关注释与标签的理解" class="headerlink" title="相关注释与标签的理解"></a>相关注释与标签的理解</h2><p>在上面的例子中，主要有两个关键的注释或标签：<code>@Many</code>和<code>&lt;collection&gt;</code>。这两个分别在注解方式和xml映射文件中使用，意思是一样的。<code>@Many</code>的<code>select</code>属性指向的是合适类型集合的映射语句。如果在该映射语句中需要参数，则要通过同一级的<code>@Result</code>标签中的<code>column</code>属性指定并传递。而一对一的关系则需要用<code>@One</code>和<code>&lt;association&gt;</code>，其用法跟一对多一样。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>关联映射</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql相似度搜索</title>
    <url>/2021/03/28/mysql-similiarity-search/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直在用模糊查询来模拟搜索引擎的搜索功能，但这种查询方式得到的结果并不太理想。比如，有一条信息<code>台湾长荣海运巨型货柜轮“长赐号”23日搁浅在苏伊士运河，造成双向航道阻塞。外媒最新报道称，“长赐号”搁浅前，其航行速度严重超出运河的限制标准。埃及总统目前已下令减轻搁浅货轮的负荷。</code>，如果使用关键字<code>苏伊士运河搁浅货轮</code>来搜索该信息，则匹配不了对应项。这就是一般模糊查询的缺陷之处，搜索的关键字必须要一一对应上信息才会有结果，因此要让搜索功能有类似搜索引擎的效果就要使用相似度/分词查询。</p>
<h2 id="mysql中的全文索引"><a href="#mysql中的全文索引" class="headerlink" title="mysql中的全文索引"></a>mysql中的全文索引</h2><p>从mysql5.7.6开始，mysql内置了<code>ngram</code>全文解析器，用于支持中文、日文、韩文的分词。通过自带引擎的分词，我们可以通过对字段建立FULLTEXT索引，进行搜索时分词器会将关键字分词进行模糊查询最后整合出结果集。</p>
<h2 id="使用全文索引的注意事项"><a href="#使用全文索引的注意事项" class="headerlink" title="使用全文索引的注意事项"></a>使用全文索引的注意事项</h2><ul>
<li>只有varchar、char、text的字段才能创建FULLTEXT索引</li>
<li>中文分词的长度用ngram_token_size设定</li>
<li>当对表写入大量数据时，先建表写入数组再建索引速度会更快</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>先设置分词长度<code>ngram_token_size</code>，大部分中文词语都是两个字符起步，因此在控制台中输入以下语句<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysqld --ngram_token_size=<span class="number">2</span>  </span><br></pre></td></tr></table></figure>
或在mysql配置文件<code>my.ini</code>中设置<code>ngram_token_size=2</code>，设置结果可通过下面语句检验<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;ngram_token_size&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>对表中要进行分词查询的字段设置全文索引<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># all_table是表名，full_index是索引名，comic_name是字段名</span><br><span class="line"># 这里必须指定分词器</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> all_comic <span class="keyword">ADD</span> FULLTEXT INDEX `full_index`(`comic_name`) <span class="keyword">WITH</span> PARSER ngram</span><br></pre></td></tr></table></figure></li>
<li>使用MATCH()…AGAINST()语句进行查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> all_comic</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (comic_name)</span><br><span class="line">against(<span class="string">&#x27;異世界後宮&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/images_chapters/similiar_search.jpg" alt="查询结果"></li>
</ol>
<h2 id="全文检索的模式"><a href="#全文检索的模式" class="headerlink" title="全文检索的模式"></a>全文检索的模式</h2><ul>
<li><p>自然语言模式(NATURAL LANGUAGE MODE)。自然语言模式是MySQL 默认的全文检索模式。自然语言模式不能使用操作符，不能指定关键词必须出现或者必须不能出现等复杂查询。</p>
</li>
<li><p>BOOLEAN模式(BOOLEAN MODE)。BOOLEAN模式可以使用操作符，可以支持指定关键词必须出现或者必须不能出现或者关键词的权重高还是低等复杂查询。</p>
</li>
<li><p>使用例子</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> all_comic</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (comic_name)</span><br><span class="line">against(<span class="string">&#x27;異世界後宮&#x27;</span> <span class="keyword">in</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br><span class="line">################################################</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> all_comic</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (comic_name)</span><br><span class="line">against(<span class="string">&#x27;+異世界 -後宮&#x27;</span> <span class="keyword">in</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>
<p><img src="/images_chapters/mode1_result.jpg" alt="自然语言模式结果"><br><img src="/images_chapters/mode2_result.jpg" alt="BOOLEAN模式结果"></p>
<ul>
<li>BOOLEAN模式其他使用方式</li>
</ul>
<p>来源于<a href="https://www.jianshu.com/p/c48106149b6a/">https://www.jianshu.com/p/c48106149b6a/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;apple banana&#39; </span><br><span class="line">无操作符，表示或，要么包含apple，要么包含banana</span><br><span class="line"></span><br><span class="line">&#39;+apple +juice&#39;</span><br><span class="line">必须同时包含两个词</span><br><span class="line"></span><br><span class="line">&#39;+apple macintosh&#39;</span><br><span class="line">必须包含apple，但是如果也包含macintosh的话，相关性会更高。</span><br><span class="line"></span><br><span class="line">&#39;+apple -macintosh&#39;</span><br><span class="line">必须包含apple，同时不能包含macintosh。</span><br><span class="line"></span><br><span class="line">&#39;+apple ~macintosh&#39;</span><br><span class="line">必须包含apple，但是如果也包含macintosh的话，相关性要比不包含macintosh的记录低。</span><br><span class="line"></span><br><span class="line">&#39;+apple +(&gt;juice &lt;pie)&#39;</span><br><span class="line">查询必须包含apple和juice或者apple和pie的记录，但是apple juice的相关性要比apple pie高。</span><br><span class="line"></span><br><span class="line">&#39;apple*&#39;</span><br><span class="line">查询包含以apple开头的单词的记录，如apple、apples、applet。</span><br><span class="line"></span><br><span class="line">&#39;&quot;some words&quot;&#39;</span><br><span class="line">使用双引号把要搜素的词括起来，效果类似于like &#39;%some words%&#39;，</span><br><span class="line">例如“some words of wisdom”会被匹配到，而“some noise words”就不会被匹配。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>相似度搜索</tag>
        <tag>分词查询</tag>
        <tag>模糊查询</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（四）spring的核心-控制反转IoC</title>
    <url>/2021/04/02/spring-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring是一款十分优秀的JAVAEE框架，其主要核心内容就是IoC（控制反转）和AOP（面向切面编程）。这一篇博文是我对IoC相关内容的理解。</p>
<h2 id="IoC和DI简介"><a href="#IoC和DI简介" class="headerlink" title="IoC和DI简介"></a>IoC和DI简介</h2><ol>
<li>IoC英文全称叫<code>Inversion of Control</code>，是面向对象编程的一种设计方案，在Spring中的体现就是把各种bean交给Spring容器进行管理，极大降低了代码的耦合度。比如，之前要使用一个javabean对象，我们要通过<code>new</code>的方式给对象进行实例化，这是在代码里写死的，也是俗称的硬编码。这些一个个对象都在代码里写着，要对它们的依赖或属性进行修改需要改动代码，这就是高耦合的一种表现。而控制反转给我们提出一种方便的解决方案，把bean交给容器，需要修改其内容时只需在配置文件里对其操作，这就极大地降低了耦合度，方便代码的重用。</li>
<li>DI英文名全称<code>Dependency Injection</code>，即是依赖注入。其跟控制反转是从不同角度描述的同一个概念。对象与对象之间总是有依赖关系的，比如对象A属性中包含对象B，通常情况下需要在A的代码中显式地<code>new</code>一个B。而使用依赖注入技术时A只需要定义一个私有的B对象，其实例化过程是由容器运行时在外部<code>new</code>出来再注入到A中。总的来说依赖注入的目的跟IoC一样都是解耦合。</li>
</ol>
<h2 id="Spring中依赖注入的方法"><a href="#Spring中依赖注入的方法" class="headerlink" title="Spring中依赖注入的方法"></a>Spring中依赖注入的方法</h2><p>既然叫注入那肯定有注入的方法。Spring给我们提供了好几种依赖注入的方法，而常用的有两种：<strong>setter注入</strong>和<strong>构造函数注入</strong></p>
<ol>
<li><p>setter注入<br>bean中需要进行注入的属性要有setter方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer stuId;</span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuId</span><span class="params">(Integer stuId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuId = stuId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuName</span><span class="params">(String stuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>且要在spring的配置文件<code>applicationContext.xml</code>中进行依赖注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.Student&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stuId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stuName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kbdog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后直接从上下文<code>context</code>中获取<code>name</code>为<code>student</code>的对象时，该对象已经被实例化且注入好属性<code>Student&#123;stuId=1, stuName=&#39;kbdog&#39;&#125;</code></p>
</li>
<li><p>构造函数注入<br>bean中要存在有参构造函数，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer stuId;</span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer stuId, String stuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuId = stuId;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>applicationContext.xml</code>中注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.Student&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kbdog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注入的属性为对象时，只需把<code>value</code>换成<code>ref</code>即可，<code>ref</code>指向的bean也要在IoC容器中</p>
</li>
</ol>
<h2 id="可进行依赖注入的类型"><a href="#可进行依赖注入的类型" class="headerlink" title="可进行依赖注入的类型"></a>可进行依赖注入的类型</h2><ul>
<li>基本类型和String</li>
<li>已在IoC容器中的bean</li>
<li>各种集合</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>控制反转</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（五）spring的面向切面编程AOP</title>
    <url>/2021/04/09/spring-2/</url>
    <content><![CDATA[<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>面向切面编程全称Aspect Oriented Programming，其可以通过切面插入一段代码，在切面执行之前或之后对其进行数据处理。AOP可以实现业务逻辑和关注点代码分离，比如每一次的业务处理之前都要进行日志的打印，要是在每个业务逻辑中都添加打印日志的内容，那代码就重复冗余且耦合度高，我们进行业务的编写最好就是明确各自的职责，各项业务分离开，实现解耦。通常aop适用于日志记录、权限控制、事务处理等方面。</p>
<h2 id="AOP的五种增强方式"><a href="#AOP的五种增强方式" class="headerlink" title="AOP的五种增强方式"></a>AOP的五种增强方式</h2><ol>
<li>before advice。这种增强方式是在join point前被执行。</li>
<li>after return advice。这种情况是join point正常执行成功后再执行。</li>
<li>after throwing advice。这种情况是joint point执行过程中抛出异常的执行结果。</li>
<li>after advice。这种情况无论join point执行过程正不正常都会执行。</li>
<li>around advice。这种情况在join point前和join point后都会执行一遍。</li>
</ol>
<h2 id="AOP在spring项目中的实现"><a href="#AOP在spring项目中的实现" class="headerlink" title="AOP在spring项目中的实现"></a>AOP在spring项目中的实现</h2><ol>
<li><p>首先来看看没有使用aop时候进行日志打印的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(BookServiceImpl.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper mapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">queryAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;====当前日期&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis())+<span class="string">&quot;====&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapper.queryAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，日志打印的代码跟业务代码耦合在一起，因此要使用aop来将打印日志的事务插入到该切面中实现解耦。</p>
</li>
<li><p>aop的实现。建一个类，使用<code>@Aspect</code>注解将其指定为切面类，在其方法中使用<code>@Pointcut</code>设置切入点，然后再根据切入点使用<code>@Before</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code>、<code>@Around</code>等进行代码的插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将其声明为切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line">    <span class="comment">//设置切面</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public * service.impl.BookServiceImpl.queryAll(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切面事务执行前</span></span><br><span class="line">    <span class="meta">@Before(&quot;setPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTransaction</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;=========&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()) +<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;@Before事务执行前:方法路径&quot;</span>+joinPoint.getTarget().getClass().getName()+<span class="string">&quot;.&quot;</span>+joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切面事务执行后返回值</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;setPointCut()&quot;,returning = &quot;response&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;=========&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()) +<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;@AfterReturning事务执行后返回正常:返回数据:&quot;</span>+response);</span><br><span class="line">        logger.info(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切面事务抛出异常</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;setPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;=========&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()) +<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;@AfterThrowing事务执行后抛出异常！&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕切点</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;setPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;事务环绕！&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;@Around前置通知！&quot;</span>);</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;@Around后置通知！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件的配置。因为Spring中AOP是使用了动态代理的方式实现，因此除了使用<code>@Aspect</code>注解声明了切面类外，还要在配置文件中进行切面的代理设置。</p>
</li>
</ol>
<p><code>applicationContext.xml</code>中的代理声明方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--切面代理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>带有<code>@Configuration</code>的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images_chapters/aop_result.jpg" alt="aop打印日志结果"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>在spring boot项目中进行全局异常处理</title>
    <url>/2021/04/04/springboot-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中我们会经常碰到异常处理的问题，比如用户在发送请求到我们的后端时如果请求参数或路径出现错误，在没做异常处理的情况下服务端会直接把一大串错误信息返回给用户。这种情况并不少见，用户获得这些信息并没有什么用处，我们后端可以对所有这种异常进行统一的处理然后提取重点统一返回封装后的数据。<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">Spring官方文档</a>给我们提供一种解决方案，使用<code>@ControllerAdvice</code>和<code>@ExceptionHandler</code>注解可以将组件注册为全局异常处理类和方法。<code>@ControllerAdvice</code>实际上就是一个增强的<code>@Controller</code>，使用该controller可以实现三个方面的功能：全局异常处理、全局数据绑定、全局数据预处理。该博文将讲解其全局异常处理的使用方法。</p>
<h2 id="异常处理类的注册与使用"><a href="#异常处理类的注册与使用" class="headerlink" title="异常处理类的注册与使用"></a>异常处理类的注册与使用</h2><ol>
<li>首先要建一个处理类，使用<code>@ControllerAdvice</code>将其注入到IoC容器中成为全局异常处理类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局异常处理</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcExceptionHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>@ExceptionHandler</code>在方法上注明要进行捕捉的异常（Exception为大部分异常的超类）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//其他情况:服务器内部异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult <span class="title">serverHandler</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器异常:&quot;</span>+e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.internal_server_error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对出现异常的情况进行返回集合的处理。通常封装类有响应编码、响应信息、响应数据这三个基本要素，我们可以对其进行封装。</li>
</ol>
<p>响应编码的枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">HttpEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理正常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OK(<span class="number">200</span>, <span class="string">&quot;请求成功&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求成功并且服务器创建了新的资源。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CREATED(<span class="number">201</span>, <span class="string">&quot;创建成功&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户发出的请求有错误，服务器没有进行新建或修改数据的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INVALID_REQUEST(<span class="number">400</span>, <span class="string">&quot;非法请求&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问内容不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NOTFOUND(<span class="number">404</span>, <span class="string">&quot;访问内容不存在&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示用户没有权限（令牌、用户名、密码错误）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UNAUTHORIZED(<span class="number">401</span>,<span class="string">&quot;抱歉，您没有权限&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示用户得到授权（与401错误相对），但是访问是被禁止的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FORBIDDEN(<span class="number">403</span>,<span class="string">&quot;禁止访问&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统内部错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INTERNAL_SERVER_ERROR(<span class="number">500</span>, <span class="string">&quot;系统内部错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HttpEnum</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取msg</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回数据封装集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseResult</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//响应编码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">//提示信息</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">//响应数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据属性构建ResponseResult</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">build</span><span class="params">( <span class="keyword">int</span> code,String msg,T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseResult&lt;T&gt;().setCode(code).setMsg(msg).setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建一些常用的</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求正常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.OK.code(),HttpEnum.OK.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">ok</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.OK.code(),HttpEnum.OK.msg(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">created</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.CREATED.code(),HttpEnum.CREATED.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非法请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">invalid_request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.INVALID_REQUEST.code(),HttpEnum.INVALID_REQUEST.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问内容不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">notFound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.NOTFOUND.code(),HttpEnum.NOTFOUND.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">unauthorized</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.UNAUTHORIZED.code(),HttpEnum.UNAUTHORIZED.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">unauthorized</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.UNAUTHORIZED.code(),HttpEnum.UNAUTHORIZED.msg(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁止访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">forbidden</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.FORBIDDEN.code(),HttpEnum.FORBIDDEN.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统内部错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResponseResult&lt;T&gt; <span class="title">internal_server_error</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(HttpEnum.INTERNAL_SERVER_ERROR.code(),HttpEnum.INTERNAL_SERVER_ERROR.msg(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter和setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意返回值类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult&lt;T&gt; <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意返回值类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult&lt;T&gt; <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意返回值类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult&lt;T&gt; <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户请求常见异常"><a href="#用户请求常见异常" class="headerlink" title="用户请求常见异常"></a>用户请求常见异常</h2><ol>
<li>请求方式错误。在后端为Restful风格的接口中，通常请求的方式都会有对应的规定。处理这种情况用的是<code>HttpRequestMethodNotSupportedException</code></li>
<li>请求参数错误。如后端要求前端使用<code>POST</code>请求来传递表单信息，若表单数据不完整或不存在，则这种情况后端会解析为数据解析异常，使用<code>HttpMessageNotReadableException</code></li>
<li>JSON格式错误。这种情况是我使用<code>fastjson</code>解析json对象时遇到的问题。如前端传递进来的json对象K-V键值对不完整<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;keyword&quot;</span>:<span class="string">&quot;关键字&quot;</span>,</span><br><span class="line">    “name”:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种情况使用<code>JSONException</code>（只有使用阿里的<code>fastjson</code>才有，若不是使用<code>fastjson</code>可无视）</li>
<li>资源不存在。这种应该是最常见的，用户访问的路径为非法路径时会报出该异常。使用<code>NoHandlerFoundException</code>。注：正常情况下使用注解方式处理全局异常是不能处理404异常的，要在配置文件<code>application.yml</code>中设置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">		<span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">resources:</span></span><br><span class="line">    	<span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>默认异常。异常有这么多不可能全部都列出来，但我们可以使用他们的超类<code>Exception</code></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（六）spring mvc的简介、各种注解以及其使用方式</title>
    <url>/2021/04/09/spring-mvc-1/</url>
    <content><![CDATA[<h1 id="spring-mvc的简介"><a href="#spring-mvc的简介" class="headerlink" title="spring mvc的简介"></a>spring mvc的简介</h1><p>spring mvc一开始就集成于spring框架中，其功能十分强大，在web项目中主要的亮点有支持RESTful风格的请求、拦截器、异常处理、国际化、数据视图解析、跨域配置等。下面讲解spring mvc与spring搭配的web项目主要用法。</p>
<h2 id="一个请求的执行过程"><a href="#一个请求的执行过程" class="headerlink" title="一个请求的执行过程"></a>一个请求的执行过程</h2><p>在使用了spring mvc的项目里，所有请求都会被spring容器中的<code>DispatcherServlet</code>拦截处理，整体过程：</p>
<ol>
<li>用户发送请求至前端控制器<code>DispatcherServlet </code></li>
<li><code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code>处理器映射器</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code></li>
<li><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器</li>
<li><code>HandlerAdapter</code>经过适配调用具体的处理器(Controller)</li>
<li>Controller执行完成返回<code>ModelAndView</code></li>
<li><code>HandlerAdapter</code>将controller执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code></li>
<li><code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code>视图解析器</li>
<li><code>ViewReslover</code>解析后返回具体View</li>
<li><code>DispatcherServlet</code>根据View进行渲染视图（将模型数据填充至视图中）</li>
<li><code>DispatcherServlet</code>响应用户</li>
</ol>
<h2 id="主要注解以及使用方式"><a href="#主要注解以及使用方式" class="headerlink" title="主要注解以及使用方式"></a>主要注解以及使用方式</h2><table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">使用方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@ResponseBody</code></td>
<td align="left">通常与<code>@Controller</code>搭配使用，将返回的对象通过转换器转换为json或xml对象</td>
</tr>
<tr>
<td align="left"><code>@RestController</code></td>
<td align="left">相当于<code>@Controller</code>与<code>@ResponseBody</code>的整合</td>
</tr>
<tr>
<td align="left"><code>@RequestMapping</code></td>
<td align="left">注解在类或方法上，其<code>value</code>值指定当前控制器url</td>
</tr>
<tr>
<td align="left"><code>@ControllerAdvice</code></td>
<td align="left">注解在全局异常处理类上，可将该类注入到ioc容器中</td>
</tr>
<tr>
<td align="left"><code>@ExceptionHandler</code></td>
<td align="left">与<code>@ExceptionHandler</code>搭配使用，注释在方法上，参数可以指定要捕捉的异常</td>
</tr>
<tr>
<td align="left"><code>@Configuration</code></td>
<td align="left">注释在配置类上，通常用于各种配置相关的内容</td>
</tr>
<tr>
<td align="left"><code>@CrossOrigin</code></td>
<td align="left">前后端分离时的跨域处理，注释在控制类或其方法上</td>
</tr>
<tr>
<td align="left"><code>@Controller</code></td>
<td align="left">标注一个类为控制器（Controller），让其接收所有http请求</td>
</tr>
<tr>
<td align="left"><code>@RequestParam</code></td>
<td align="left">注解在控制器方法参数列表中，获取url中所带的参数</td>
</tr>
</tbody></table>
<h2 id="ModelAndView的使用"><a href="#ModelAndView的使用" class="headerlink" title="ModelAndView的使用"></a>ModelAndView的使用</h2><p>在前后端不分离的情况下，<code>Controller</code>可以通过返回一个<code>ModelAndView</code>来传递返回的数据与解析视图。从名称上来看就可以知道，其囊括了MVC三层架构中的model层与view层。<br>要让其跳转到相应的视图则要在配置文件中配置视图解析器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置视图解析器(InternalResourceViewResolver) --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;parser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 给所有的返回值增加前缀/views/,增加后缀.jsp --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/views/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里返回的视图为success.jsp，传递的对象为student1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ModelAndView mv=<span class="keyword">new</span> ModelAndView(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">	Student student=<span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">	mv.addObject(<span class="string">&quot;student1&quot;</span>, student);</span><br><span class="line">	<span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前后端分离通过json传递数据"><a href="#前后端分离通过json传递数据" class="headerlink" title="前后端分离通过json传递数据"></a>前后端分离通过json传递数据</h2><p>现在大部分的web项目都会进行前后端分离解耦，前端跟后端不在同一个项目中，后端不需要负责前端页面的渲染，只需要接收前端请求然后响应数据即可。而这前后端交互的过程中后端通常都是把数据结果集封装成json对象返回给前端。这个过程可以通过在Controller中使用<code>@RestController</code>实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/queryMagnet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagnetController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MagnetService service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询所有磁力链接</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/all&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ResponseResult <span class="title">queryAllMagnet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Magnet&gt; magnetList=service.queryAllMagnet();</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.ok(magnetList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images_chapters/springmvc_result1.jpg" alt="Postman请求结果"></p>
<h2 id="跨域请求的处理方法"><a href="#跨域请求的处理方法" class="headerlink" title="跨域请求的处理方法"></a>跨域请求的处理方法</h2><p>如果是前端项目通过浏览器发送的请求要注意跨域的问题，这时后端要在controller上添加<code>@CrossOrigin</code>或通过<code>@Configuration</code>配置类的方式解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="comment">//跨域设置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许证书</span></span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;PATCH&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>这个内容前几天已经发布过了，链接<a href="https://kbdog.github.io/2021/04/04/springboot-1/">https://kbdog.github.io/2021/04/04/springboot-1/</a></p>
<h2 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h2><p>拦截器的实现思想是AOP，由<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-handlermapping-interceptor">Spring官方文档</a>可以知道拦截器要实现<code>HandlerInterceptor</code>接口。<code>HandlerInterceptor</code>接口中主要有三个方法<code>postHandle</code>、<code>afterCompletion</code>、和<code>preHandle</code>。分别对应于Controller运行之后、完整的请求之后、实际处理的Controller之前。因此，<code>preHandle</code>是其中最主要的方法，该方法返回值为<code>boolean</code>，若返回<code>true</code>，则拦截器放行，请求继续执行，若为<code>false</code>则相反。通常拦截器应用在路径验证、权限验证、日志打印等方面。以下是其实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在controller前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经过拦截器...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请求链接:&quot;</span>+request.getRequestURL());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在controller后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle:访问controller完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个过程结束后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion:整个过程完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截器写好后还要将其添加到配置类/文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="comment">//拦截器设置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">       registry.addInterceptor(<span class="keyword">new</span> ApiInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>前后端分离</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>插入aplayer插件</title>
    <url>/2021/01/18/test_blog_1/</url>
    <content><![CDATA[<h2 id="测试插入aplayer插件"><a href="#测试插入aplayer插件" class="headerlink" title="测试插入aplayer插件"></a>测试插入aplayer插件</h2>
        <div id="aplayer-uQkzBPMR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>
			  <script>
				  var options = {"narrow":false,"autoplay":false,"showlrc":3,"volum":0.2,"music":[{"title":"稻香","author":"周杰伦","url":"/musiclist/周杰伦 - 稻香.mp3","pic":"/images_chapters/beauty.jpg"},{"title":"给我一首歌的时间-周杰伦","author":"周杰伦","url":"/musiclist/给我一首歌的时间-周杰伦.mp3","pic":"/images_chapters/beauty.jpg"}]};
				  options.element = document.getElementById("aplayer-uQkzBPMR");
				  var ap = new APlayer(options);
			    window.aplayers || (window.aplayers = []);
				  window.aplayers.push(ap);
			  </script>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>aplayer</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>插入代码</title>
    <url>/2021/01/19/test_blog_2/</url>
    <content><![CDATA[<h2 id="测试插入代码"><a href="#测试插入代码" class="headerlink" title="测试插入代码"></a>测试插入代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> []args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>插入图片</title>
    <url>/2021/01/19/test_blog_3/</url>
    <content><![CDATA[<h2 id="测试图片插入"><a href="#测试图片插入" class="headerlink" title="测试图片插入"></a>测试图片插入</h2><p><img src="/images_chapters/beauty.jpg" alt="有描述性文字的图片"><br><img src="/images_chapters/comet.jpg"></p>
<div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"><br><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"> </p>
          </div>

]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>插入dplayer插件</title>
    <url>/2021/01/20/test_blog_4/</url>
    <content><![CDATA[<h2 id="测试添加视频"><a href="#测试添加视频" class="headerlink" title="测试添加视频"></a>测试添加视频</h2><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FF69B4","lang":"zh-cn","preload":"auto","volume":0.7,"video":{"url":"/medialist/小碧蓝幻想.mkv","pic":"/images_chapters/beauty.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<h2 id="github例子"><a href="#github例子" class="headerlink" title="github例子"></a>github例子</h2><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4","pic":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","addition":["https://dplayer.daoapp.io/bilibili?aid=4157142"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>dplayer</tag>
      </tags>
  </entry>
  <entry>
    <title>插入标签</title>
    <url>/2021/01/21/test_blog_5/</url>
    <content><![CDATA[<div class="note simple"><p>默认提示块标签</p>
</div>

<div class="note default simple"><p>default提示块标签</p>
</div>

<div class="note primary simple"><p>primary提示块标签</p>
</div>

<div class="note success simple"><p>success提示块标签</p>
</div>

<div class="note info simple"><p>info提示块标签</p>
</div>

<div class="note warning simple"><p>warning提示块标签</p>
</div>

<div class="note danger simple"><p>danger提示块标签</p>
</div>

]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架学习（七）Spring中的事务管理</title>
    <url>/2021/04/25/transaction/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我的项目中事务处理都是直接在对应事务方法上加<code>@Transacational</code>注解让spring容器帮我处理，但其具体有哪些细节并不是太了解。在浏览许多博客学习之后，我对spring的事务处理有了更清晰的认识。</p>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>首先，事务是什么？简单理解事务就是一组操作。比如增删改查，对于数据库来说这些操作要么成功执行提交要么不执行回滚。事务最经典的例子就是转账：A要给B转账1000元，这个过程包含两个关键操作</p>
<ol>
<li>将A的账户减少1000元</li>
<li>将B的账户增加1000元</li>
</ol>
<p>如果在整个过程中出现异常比如网络问题，A的账户减少了1000元但是B的账户却没有增加金钱，这样整个事务必须回滚到执行前的状态。事务就是保证操作要么成功要么失败，这是事务的原子性。在业务中我们最常使用到事务的是数据库操作。</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul>
<li>原子性（Atomicity）： 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>一致性（Consistency）： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>隔离性（Isolation）： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h2 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h2><p>Spring提供两种方式对事务进行处理：</p>
<ol>
<li>编程式事务处理。通过<code>TransactionTemplate</code>或者<code>TransactionManager</code>手动对事务进行提交和回滚。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TransacationTemplate管理事务</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//具体事务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//手动回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TransactionManager管理事务</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//具体事务操作</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          	  <span class="comment">//捕捉异常手动回滚</span></span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>声明式事务处理。通过<code>@Transactional</code>注解让容器进行处理。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
两个事务例子来源于：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93.md</a></li>
</ol>
<h2 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h2><p>如果带事务的方法A调用带事务的方法B，A出现异常了B会不会回滚？反过来呢？这些事务之间的调用问题执行结果就需要根据事务的传播行为来决定。<br>首先要知道spring中传播行为有哪些：</p>
<ul>
<li><p><code>PROPAGATION_REQUIRED</code>。使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>例子</strong>：AB都使用<code>PROPAGATION_REQUIRED</code>。A调B，无论是A出现异常还是B出现异常整个过程都会回滚。</p>
</li>
<li><p><code>PROPAGATION_REQUIRES_NEW</code>。创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。<strong>例子</strong>：A使用<code>PROPAGATION_REQUIRED</code>，B使用<code>PROPAGATION_REQUIRES_NEW</code>，A调B，如果A出现异常，B的事务照样成功提交，而A自身回滚；但如果B抛出异常且未被手动捕获(<code>try...catch</code>)则A和B都回滚</p>
</li>
<li><p><code>PROPAGATION_NESTED</code>。如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>PROPAGATION_REQUIRED</code>。也就是说，在外部方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。如果外部方法开启事务的话，<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。<strong>例子</strong>：A使用<code>PROPAGATION_REQUIRED</code>，B使用<code>PROPAGATION_NESTED</code>，A调B，如果B出现异常则B回滚而A不回滚；但A出现异常则AB都回滚</p>
</li>
<li><p><code>PROPAGATION_MANDATORY</code>。如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）。方法必须在一个已存在事务中执行。<strong>例子</strong>：A不使用事务，B使用<code>PROPAGATION_MANDATORY</code>，A调B，无论B是否出现异常都会抛异常，B事务不会执行；如果A使用事务并使用<code>PROPAGATION_REQUIRED</code>，则B事务属于A事务，B出现异常回滚则A也回滚</p>
</li>
<li><p><code>PROPAGATION_SUPPORTS</code>。如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<strong>例子</strong>：B使用<code>PROPAGATION_SUPPORTS</code>，如果A存在事务且传播行为是<code>PROPAGATION_REQUIRED</code>，则B抛异常AB一起回滚；如果A不存在事务则相当于两个都没开启事务，不存在回滚。</p>
</li>
<li><p><code>PROPAGATION_NOT_SUPPORTED</code>。以非事务方式运行，如果当前存在事务，则把当前事务挂起。<strong>例子</strong>：A不使用事务，B使用<code>PROPAGATION_NOT_SUPPORTED</code>，A调B，则相当于两个都不使用事务，不会存在回滚操作；如果A存在事务，则会挂起A，先执行B，如果没抛异常则无事发生。</p>
</li>
<li><p><code>PROPAGATION_NEVER</code>。以非事务方式运行，如果当前存在事务，则抛出异常。跟<code>PROPAGATION_MANDATORY</code>相反，方法不能在事务中执行。<strong>例子</strong>：B使用<code>PROPAGATION_NEVER</code>，A调B，如果A使用事务则抛异常，相当于强制AB都不使用事务。</p>
</li>
</ul>
<p><strong>通常用的有<code>PROPAGATION_REQUIRED</code>、<code>PROPAGATION_REQUIRES_NEW</code>、<code>PROPAGATION_NESTED</code>，如果错误的配置了<code>PROPAGATION_SUPPORTS</code>、<code>PROPAGATION_NOT_SUPPORTED</code>、<code>PROPAGATION_NEVER</code>这三种传播行为，事务将不会回滚。毕竟我们是用事务管理目的就是在业务出现异常时让操作回复到原本的状态，所以传播行为使用前三种足够了</strong></p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li><p>ISOLATION_DEFAULT :使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别， Oracle 默认采用的 READ_COMMITTED 隔离级别.</p>
</li>
<li><p>ISOLATION_READ_UNCOMMITTED :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p>
</li>
<li><p>ISOLATION_READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p>
</li>
<li><p>ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
</li>
<li><p>ISOLATION_SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。通过上锁的操作让所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p>
</li>
</ul>
<h2 id="Transactional注解的属性以及使用"><a href="#Transactional注解的属性以及使用" class="headerlink" title="@Transactional注解的属性以及使用"></a>@Transactional注解的属性以及使用</h2><h3 id="Transactional使用范围"><a href="#Transactional使用范围" class="headerlink" title="@Transactional使用范围"></a>@Transactional使用范围</h3><ul>
<li>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</li>
<li>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li>
<li>接口 ：不推荐在接口上使用。</li>
</ul>
<h3 id="timeout超时时间"><a href="#timeout超时时间" class="headerlink" title="timeout超时时间"></a>timeout超时时间</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为-1，即是不超时。</p>
<h3 id="readOnly只读"><a href="#readOnly只读" class="headerlink" title="readOnly只读"></a>readOnly只读</h3><p>事务为只读事务，如果里面存在对数据库的增删改操作则会抛出异常并回滚</p>
<h3 id="isolation隔离级别"><a href="#isolation隔离级别" class="headerlink" title="isolation隔离级别"></a>isolation隔离级别</h3><p>设置事务的隔离级别</p>
<h3 id="propagation传播行为"><a href="#propagation传播行为" class="headerlink" title="propagation传播行为"></a>propagation传播行为</h3><p>设置事务的传播行为</p>
<h3 id="rollbackFor和noRollbackFor"><a href="#rollbackFor和noRollbackFor" class="headerlink" title="rollbackFor和noRollbackFor"></a>rollbackFor和noRollbackFor</h3><p>自定义回滚或不回滚异常</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中线程的创建方式与线程池的使用</title>
    <url>/2021/04/22/thread/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天做了一家公司的笔试题，结果感觉不太好。题目大多数是基础题，很少涉及到框架相关的内容，果然对实习生来说还是基础知识重要点= =。最后两道是手写编程题，一道要求手写单例模式、另一道jvm内存回收。设计模式前几天刚复习过，最后写出来感觉还行，但第二道就难受了，jvm虚拟机部分几乎没怎么涉及过，就空了交卷。接下来要好好复习基础。回到正题，今天要说的是线程的创建方式和线程池的使用。</p>
<h2 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h2><ul>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>继承Thread类</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p>
<ol>
<li>实现Runnable接口并实现<code>run()</code>方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;runnable：run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现Callable接口并实现<code>call()</code>方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call返回值通过FutureTask封装，使用FutureTask.get()方法获得返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableImpl</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;callable: call&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>继承Thread类并重写<code>run()</code>方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExtend</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread: run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>三种创建线程的方式一一通过<code>start()</code>执行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestCreateThread</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">//实现runnable接口</span></span><br><span class="line">       Runnable runnable=<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">       Thread thread1=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">       thread1.start();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//实现callable接口</span></span><br><span class="line">       CallableImpl callable = <span class="keyword">new</span> CallableImpl();</span><br><span class="line">       FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">       Thread thread2=<span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">       thread2.start();</span><br><span class="line">       System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//thread继承</span></span><br><span class="line">       Thread thread3=<span class="keyword">new</span> ThreadExtend();</span><br><span class="line">       thread3.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<img src="/images_chapters/create_thread.jpg" alt="创建线程结果"><br>注意，线程开启要使用<code>start()</code>方法，而不是使用<code>run()</code>。<code>start()</code>是启动一个线程，此时的线程处于就绪状态，等时间片到即开始运行。<code>run()</code>并没有开辟一个线程，仅仅是在当前的线程中执行<code>run()</code>方法。</li>
</ol>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>线程池实现类的顶层接口是<code>Executor</code>，顶层接口<code>Executor</code>提供了一种思想：将任务提交和任务执行进行解耦。开发者无需关注如何创建线程，如何调度线程来执行任务，开发者只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到执行器<code>Executor</code>中，由<code>Executor</code>框架完成线程的调配和任务的执行部分。<br><img src="/images_chapters/executor_uml.jpg" alt="Executor继承关系类图"></p>
<ol>
<li><code>ExecutorService</code>接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成<code>Future</code>的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</li>
<li><code>AbstractExecutorService</code>则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</li>
<li>最下层的实现类<code>ThreadPoolExecutor</code>实现最复杂的运行部分，<code>ThreadPoolExecutor</code>将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</li>
</ol>
<p>主要的<code>Executor</code>有三种：<code>CachedThreadPool</code>、<code>FixedThreadPool</code>、<code>SingleThreadExecutor</code>，都可通过<code>Executors</code>获得，返回值是<code>ExecutorService</code>。</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<p>线程池的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//创建大小为2的线程池</span></span><br><span class="line">       ExecutorService threadPool=Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> tmp=i;</span><br><span class="line">           <span class="comment">//执行线程任务</span></span><br><span class="line">           threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   System.out.println(tmp);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//关闭线程池</span></span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images_chapters/threadpool1.jpg" alt="创建线程池结果"></p>
<p>通常我们使用多线程都是进行一些并发的操作，如下载等。那么我们想要记录一下线程执行结果可以通过<code>ExecutorService</code>的<code>submit()</code>提交任务后的返回值来获得，或者通过<code>CompletionService</code>来对任务执行结果进行处理。<code>CompletionService</code>中<code>take()</code>可获得<code>Future</code>对象，根据其<code>get()</code>方法我们可以获得线程返回值。<code>take()</code>方法返回的是最早执行完毕的任务结果，所以在下载记录进度的这种情况下我们使用<code>CompletionService</code>会更加的方便</p>
<p>使用<code>CompletionService</code>对线程池返回值进行管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> times=<span class="number">10</span>;</span><br><span class="line">       <span class="comment">//通常有三种线程池，1、固定线程数量FixedThreadPool   2、只提供单个线程SingleThreadExecutor  3、一个任务创一个线程CachedThreadPool</span></span><br><span class="line">       <span class="comment">//大小为5的线程池</span></span><br><span class="line">       ExecutorService threadPool= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">       <span class="comment">//管理每个线程返回值</span></span><br><span class="line">       CompletionService&lt;Integer&gt; cs=<span class="keyword">new</span> ExecutorCompletionService&lt;Integer&gt;(threadPool);</span><br><span class="line">       <span class="comment">//提交线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times;i++)&#123;</span><br><span class="line">           <span class="keyword">final</span> Integer tmp=i;</span><br><span class="line">           <span class="comment">//用CompletionService提交</span></span><br><span class="line">           cs.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                       <span class="keyword">return</span> tmp;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(threadPool.isShutdown()==<span class="keyword">false</span>)&#123;</span><br><span class="line">           Integer integer=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//线程执行结果</span></span><br><span class="line">               integer = cs.take().get();</span><br><span class="line">               <span class="keyword">if</span>(integer!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(count==<span class="number">10</span>)&#123;</span><br><span class="line">                   <span class="comment">//执行完毕关闭线程池:已提交的会继续执行到完毕，不再接收新的线程</span></span><br><span class="line">                   threadPool.shutdown();</span><br><span class="line">                   System.out.println(<span class="string">&quot;当前线程执行结果返回值:&quot;</span>+integer+<span class="string">&quot;-&quot;</span>+count+<span class="string">&quot;/10&quot;</span>);</span><br><span class="line">                   System.out.println(<span class="string">&quot;finish!&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;当前线程执行结果返回值:&quot;</span>+integer+<span class="string">&quot;-&quot;</span>+count+<span class="string">&quot;/10&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images_chapters/threadpool2.jpg" alt="使用CompletionService对线程池进行管理结果"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下这个不一般的五月</title>
    <url>/2021/05/29/saysomething1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一个月事情有点多，准备实习笔试、面试、当伴郎、软考、课程作业等等，太忙了没更新过博客。今天下午刚好考完软考，最近一系列的事情也算是落幕了，压力也缓解了不少。今天写个杂谈来记录下这个月的心路历程吧。</p>
<h2 id="当伴郎"><a href="#当伴郎" class="headerlink" title="当伴郎"></a>当伴郎</h2><p>这是我第一次当伴郎。说实话当我哥私聊我让我给他当伴郎的时候我是很迷茫的，这么多人选为什么会找上我呢，不过我知道这是对我的肯定，所以在上个月中旬我购置了一套正装。穿上正装照上镜子的那一刻我突然意识到原来一个普普通通的肥仔打扮一下也能人模人样。婚礼那天要接新娘，作为伴郎的我要帮忙做很多工作，贴花车、放礼炮、派红包，伴郎团几个人一起忙前忙后其实挺快乐的。接新娘时候要做游戏搞气氛，社恐的我在旁边尬站着，还好伴郎团给力，最后气氛还是搞起来了。到晚上婚礼摆酒席，看到在司仪的引导下大哥大嫂互诉爱意后，作为堂弟的我感到十分欣慰，大哥单身了这么多年终于走进婚姻的殿堂了，也算是了了人生的一件大事。最后简单的祝大哥大嫂新婚快乐吧。（文笔太差了写得像小学生作文=，=）</p>
<h2 id="实习笔试、面试"><a href="#实习笔试、面试" class="headerlink" title="实习笔试、面试"></a>实习笔试、面试</h2><p>其实我从这个学期开始就在找实习了，不过发出的简历几乎都石沉大海，但是最后还是有几家公司向我抛来了橄榄枝。最开始收到的是广州的某家公司的邀请，说是不用笔试让我直接过去面试，在考虑了路途和当时仍未清晰的大四课程安排后我还是拒了。然后就是在珠海本地的一家企业（这家企业我也很早就投过简历，不过当时没有回复，我想应该是招聘实习生的具体工作还没安排下来），这家企业直接来我们学校办宣讲会笔试，我去做了一遍，笔试内容应该算是比较简单的，所以我顺利的进了面试。接下来半个月我几乎每天都在牛客网上刷题，看csnotes的基础知识（其实整个过程我觉得我也只是囫囵吞枣地过了几遍）。到了面试这天，我特意找了个面试时间没人的实验室，把自我介绍背了又背。整个视频面试的过程氛围挺轻松，面试官挺友好的。原本我以为会问一些基础的问题，但面试官直接问我的项目内容（简历上写的），问到我自己的项目那我肯定是自信满满的，所以我就把问到的项目的内容，功能等描述了一遍。当时介绍完自己的项目后我还有点小庆幸，然后面试官从一些基础的部分问起我就傻眼了。我的前端部分是比较薄弱的，vue也只是会用而已，里面实际的什么原理我都不懂，当时面试官让我讲下router，我其实没理解这个问题，就回答了项目中vue的路由访问实现过程，回答完看了眼面试官我就知道结果很不满意；还有个问题是让我说一下RESTful api接口，其实RESTful风格的接口很好解释，就是get、post、put、patch、delete等请求方式对应上实际增删改查方法，但当时不知道为什么我脑子一片空白，就记起个get、post、put，其他的也没讲出来，草草地讲了一下就放弃了。接下来我整个人慌了，后面的问题我几乎都是不带脑子的回答。比如问到http的请求，我就记得写爬虫项目抓包时候用到的几个请求头，就硬着头皮答了，答完面试官：“这些是请求头吧，我问的是http请求啊”，然后我更慌了。后面的问题答得都不好，到最后一个让我介绍下非对称加密时候，我充满了自信，因为那段时间我也一直在准备软考，有复习到加密相关的知识点，但明显我的嘴跟脑子配合的不是很好，就说了下非对称加密有两套密钥，然后就没了，面试官应该也感到无奈了。那时候我已经知道面试结果了。总结来说，我准备的还是不充足，只能继续努力了。</p>
<h2 id="软考"><a href="#软考" class="headerlink" title="软考"></a>软考</h2><p>软考这个也是很早就开始准备了，考的是软件设计师。三月份时候我就把近几年软考的真题都复印了下来刷，同时还在b站上看软考相关的教学视频。到四月中旬我已经把几套上午的题都刷烂了，下午的题就时不时刷一下。今天软考正式开考，准备了这么久的知识也派上用场了。整个考试过程其实没什么好说的，总结一下就是上午题感觉还行，下午题有点难度，不过都考完了就一切都过去了（现在算是放假躺尸time哈哈）。</p>
<h2 id="A-SOUL"><a href="#A-SOUL" class="headerlink" title="A-SOUL"></a>A-SOUL</h2><p>这个作为压轴来讲吧。最早遇到这个虚拟女团是在动物园视频（otto、山泥若、炫狗等lol主播）的相关的推荐里，点进这个虚拟女团的视频，看了眼评论区，里面几乎都是各种网络亚文化“梗”的集合，粉丝成分很明显，就是抗吧的人。我玩贴吧也很多年了，从初中开始到现在大三。最早接触的是各种小说贴吧，没错，当时我玩贴吧就是为了追免费小说，后来玩了英雄联盟，看上了英雄联盟电竞赛事（LPL），就自然而然找些讨论赛事的贴吧看。当年的lol吧、英雄联盟吧里内容几乎都是没什么营养的，要是用lol的游戏术语说就是整天都在讨论“六神蛮子跟六神剑圣哪个强”。这时抗压吧就进入了我的视野。这个贴吧讨论电竞赛事，分享电竞相关新闻，跟几个被戏称为“幼儿园”的英雄联盟相关的贴吧的风格完全不同。于是，我爱上了这个贴吧。其实抗压吧最让我喜欢的一点是它的“真实”。在外人看来抗压吧是一个粪坑，是一个厕所，里面充满了“负能量”，因为里面的老哥们很“嘴臭”，遇到不爽的事就直接开骂，吧务也不管。其实反过来想一想，大家上网几乎都是找快乐、发泄自我的，在网上就不要再压抑自己了，想说啥就说啥，而其他贴吧都管得十分严，不准发布任何“喷人”的内容，所以抗压吧也成了一个泄压口，热度在百度贴吧年年榜首，大家在里面发泄着自我，寻找着属于自己的快乐，发泄完回到现实该当孙子还是当孙子。我记得以前有个贴，是某个吧友的母亲患病，需要一大笔治疗费用，他迫于无奈来贴吧众筹。当时的抗压吧可以说是最和谐的了，一个个“嘴臭战神”都展现出自己温柔的一面，有钱的出钱，没钱的也献上自己的祝福。其实大家都不是“蛆”，都是跟生活抗争的普通人而已。近几年抗吧热度上去后越来越多引流来的吧友，所以抗吧也成了网络亚文化梗的大杂烩。回到A-SOUL这个主题，当时我看到A-SOUL的评论区我就觉得我肯定可以融入，于是我开始自己搜索这个虚拟女团相关的内容。那时候应该是4月份，我正准备着实习、软考、课程设计，各种事情接踵而来，我忙得焦头烂额，每天都烦躁不堪，因为已经戒了游戏一年多了，所以也几乎没有什么娱乐的内容，没有娱乐，就没有泄压的方向。这时asoul进入了我的世界，这个虚拟女团有五个人，平时直播内容就是唱歌跳舞聊天打游戏等，其实最令我惊讶的是她们企划所使用的动捕技术，她们的动捕技术来自字节跳动，相比同行的动捕技术，她们的动捕能细致到每一根手指、每一个表情，所以她们的直播节目跟观众互动效果是十分良好的。之前我对这些虚拟主播是不屑一顾的，认为就是一些套皮以卖萌为卖点的女主播骗骗傻卵二刺猿的钱而已。A-soul彻底改变了我的看法，她们每个成员都有良好的歌唱、舞蹈功底，这些在字节的动捕技术下很好的表现了出来，跟真正的女团对比其实也就是多了一层虚拟的动画表皮而已。不过就是多了这层虚拟皮才能收到抗吧“鼠鼠”们的青睐，大家平时现实工作学习生活就挺累的，来到网上就想享受一下虚拟世界，A-soul这种位于虚拟与真实之间且有实力的女团就成了抗吧老哥们追捧的对象。那段时间我压力蛮大的，看看几个女生跳舞、唱歌、电台聊天、打游戏的录播视频之后，压力立刻得到了缓解。人也像机器，也需要喘息、需要泄压，感谢这个虚拟女团，希望她们公司的企划能越做越好，走向更大的舞台。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实总结也没什么好总结的，整个四月五月几乎都在准备考证、实习，这些压力对我一个还未出社会的大学生来说不算什么。看看每天起早贪黑上班工作养家的打工人，大家都在为了生活在继续努力工作、努力活着，他们的压力是生活上的压力，而我的压力只是一个个考试，只是对未来的迷茫，所以我的压力真不算什么。最后用抗压吧的一句话来结尾吧，<strong>人生何时不抗压</strong></p>
<h2 id="引流"><a href="#引流" class="headerlink" title="引流"></a>引流</h2><ul>
<li><a href="https://www.bilibili.com/video/BV19h411Q7fW">A-soul嘉然 《不可思议》</a></li>
<li><a href="https://www.bilibili.com/video/BV1bz4y1z7uu">A-soul嘉然读打工人小作文破防</a></li>
<li><a href="https://www.bilibili.com/video/BV1vQ4y1Z7C2">A-soul团曲《超级敏感》</a></li>
<li><a href="https://www.bilibili.com/video/BV1YK411V7N3">A-soul团曲《quiet》</a></li>
<li><a href="https://www.bilibili.com/video/BV1dK411F7nw">A-soul《夏天的风》</a></li>
<li><a href="https://www.bilibili.com/video/BV1sz4y117pi">A-soul《情非得已》</a></li>
<li><a href="https://www.bilibili.com/video/BV1p5411w71j">A-soul的粉丝自创单曲民谣《枝江》</a></li>
<li><a href="https://www.bilibili.com/video/BV1qZ4y1A7FA">A-soul的粉丝自创rap歌曲《嘉然我想对你说》</a></li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>软考</tag>
        <tag>A-soul</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch入门</title>
    <url>/2021/08/06/elasticsearch-1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>类比mysql等关系型数据库，elasticsearch这种nosql的搜索引擎效率更快，通常的案例有百度淘宝等即时搜索功能<br>Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns<br>关系型数据库       数据库             表             行           列<br>Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields<br>Elasticsearch       索引            类型            文档            域（字段）</p>
<h2 id="elasticsearch安装-windows"><a href="#elasticsearch安装-windows" class="headerlink" title="elasticsearch安装(windows)"></a>elasticsearch安装(windows)</h2><ol>
<li>上<a href="https://www.elastic.co/cn/downloads/elasticsearch">官网</a>下载压缩包</li>
<li>解压缩</li>
<li>运行<code>bin</code>目录下的<code>elasticsearch.bat</code>批处理文件</li>
<li>cd到对应目录在dos命令行<code>elasticsearch-service.bat install</code>安装<code>elasticsearch</code>服务</li>
<li>访问<code>localhost:9200</code>(默认端口)</li>
</ol>
<h2 id="kibana可视化工具安装-windows"><a href="#kibana可视化工具安装-windows" class="headerlink" title="kibana可视化工具安装(windows)"></a>kibana可视化工具安装(windows)</h2><ol>
<li>上<a href="https://www.elastic.co/cn/downloads/kibana">官网</a>下载压缩包</li>
<li>解压缩</li>
<li>运行<code>bin</code>目录下的<code>kibana.bat</code>（git-bash可用<code>cmd.exe /C kibana</code>运行）</li>
<li>访问<code>localhost:5601</code>(默认端口)</li>
</ol>
<h2 id="elasticsearch在java中的使用方式"><a href="#elasticsearch在java中的使用方式" class="headerlink" title="elasticsearch在java中的使用方式"></a>elasticsearch在java中的使用方式</h2><h3 id="RestHighLevelClient的使用"><a href="#RestHighLevelClient的使用" class="headerlink" title="RestHighLevelClient的使用"></a>RestHighLevelClient的使用</h3><p><code>RestHighLevelClient</code>即是Elasticsearch的一个高级客户端，对Elasticsearch集群的所有操作都要经过该客户端来操作。其在java中可通过低级客户端<code>RestClient</code>来获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestHighLevelClient</span><span class="params">(RestClientBuilder restClientBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(restClientBuilder, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对索引Index的操作"><a href="#对索引Index的操作" class="headerlink" title="对索引Index的操作"></a>对索引Index的操作</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>在<code>elasticsearch</code>中索引就是类似数据库的结构，我们可通过创建一个<code>CreateIndexRequest</code>，让客户端来执行创建请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CreateIndexRequest request=<span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;new_index&quot;</span>);</span><br><span class="line">CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"><span class="comment">//获得创建结果:boolean</span></span><br><span class="line">System.out.println(response.isAcknowledged());</span><br></pre></td></tr></table></figure>
<p>同时也可对<code>CreateIndexRequest</code>的各种设置参数的方法来对所创建的索引结构进行设置（如分词器，过滤器等），此处不再一一说明。</p>
<h4 id="判断索引是否存在"><a href="#判断索引是否存在" class="headerlink" title="判断索引是否存在"></a>判断索引是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existIndex</span><span class="params">(String index)</span> </span>&#123;</span><br><span class="line">    GetIndexRequest request=<span class="keyword">new</span> GetIndexRequest(index);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteIndex</span><span class="params">(String index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(!existIndex(index))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DeleteIndexRequest request=<span class="keyword">new</span> DeleteIndexRequest(index);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AcknowledgedResponse response = client.indices().delete(request,</span><br><span class="line">                RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.isAcknowledged();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对文档Document的操作"><a href="#对文档Document的操作" class="headerlink" title="对文档Document的操作"></a>对文档Document的操作</h3><p>文档<code>document</code>类比数据库中的行，元组，通常搜索出来的元数据结果就是以每个文档为单位。每个文档都有特定的<code>id</code>，所以以下与特定文档相关的方法都会包含<code>id</code>这个参数</p>
<h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*index:索引的名称</span></span><br><span class="line"><span class="comment">*id:在索引中设置的id(如果不手动设也可以，会自动分配id)</span></span><br><span class="line"><span class="comment">*content:向index中添加的document元组,格式为json</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createDocument</span><span class="params">(String index, String id, String content)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查看文档是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(existDocument(index,id))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IndexRequest request=<span class="keyword">new</span> IndexRequest(index).id(id);</span><br><span class="line">    request.source(content, XContentType.JSON);</span><br><span class="line">    IndexResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (response.status()==RestStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断文档是否存在"><a href="#判断文档是否存在" class="headerlink" title="判断文档是否存在"></a>判断文档是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String index, String id)</span></span>&#123;</span><br><span class="line">    GetRequest request=<span class="keyword">new</span> GetRequest(index,id);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> client.exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取文档"><a href="#获取文档" class="headerlink" title="获取文档"></a>获取文档</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这里获得的返回结果为json字符串</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDocument</span><span class="params">(String index, String id)</span> </span>&#123;</span><br><span class="line">    GetRequest request=<span class="keyword">new</span> GetRequest(index,id);</span><br><span class="line">    GetResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.getSourceAsString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateDocument</span><span class="params">(String index, String id, String content)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断文档是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(!existDocument(index,id))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UpdateRequest request=<span class="keyword">new</span> UpdateRequest(index,id);</span><br><span class="line">    request.doc(content,XContentType.JSON);</span><br><span class="line">    UpdateResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (response.status()==RestStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteDocument</span><span class="params">(String index, String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!existDocument(index,id))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DeleteRequest request=<span class="keyword">new</span> DeleteRequest(index,id);</span><br><span class="line">    DeleteResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (response.status()==RestStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>我们可以通过<code>BulkRequest</code>来对多个<code>DocWriteRequest</code>(<code>DeleteRequest</code>,<code>IndexRequest</code>,<code>UpdateRequest</code>)操作进行添加集成，然后统一让<code>RestHighLevelClient</code>执行对文档的批量操作，下面封装了一个进行批量操作的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bulkRequest</span><span class="params">(String index, Iterable&lt;DocWriteRequest&lt;?&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">    BulkRequest bulkRequest=<span class="keyword">new</span> BulkRequest();</span><br><span class="line">    requests.forEach(x-&gt;&#123;</span><br><span class="line">        bulkRequest.add(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    BulkResponse responses = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        responses = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    BulkItemResponse[] items = responses.getItems();</span><br><span class="line">    <span class="keyword">for</span>(BulkItemResponse tmp:items)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;操作:&quot;</span>+tmp.getOpType().name()+<span class="string">&quot;-主键id:&quot;</span>+tmp.getId()+<span class="string">&quot;-是否成功:&quot;</span>+(!tmp.isFailed()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !responses.hasFailures();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用用例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBulkOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加document操作</span></span><br><span class="line">    IndexRequest indexRequest=<span class="keyword">new</span> IndexRequest(<span class="string">&quot;desktop&quot;</span>).id(<span class="string">&quot;testId&quot;</span>)</span><br><span class="line">        .source(XContentType.JSON,<span class="string">&quot;testField1&quot;</span>,<span class="string">&quot;testField1&quot;</span>);</span><br><span class="line">    <span class="comment">//修改document操作</span></span><br><span class="line">    JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</span><br><span class="line">    jsonObject.put(<span class="string">&quot;programId&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    jsonObject.put(<span class="string">&quot;programName&quot;</span>,<span class="string">&quot;网易云音乐-updated&quot;</span>);</span><br><span class="line">    UpdateRequest updateRequest=<span class="keyword">new</span> UpdateRequest(<span class="string">&quot;desktop&quot;</span>,<span class="string">&quot;1006&quot;</span>)</span><br><span class="line">        .doc(jsonObject.toJSONString(),XContentType.JSON);</span><br><span class="line">    <span class="comment">//操作集合</span></span><br><span class="line">    List&lt;DocWriteRequest&lt;?&gt;&gt;requests=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    requests.add(indexRequest);</span><br><span class="line">    requests.add(updateRequest);</span><br><span class="line">    System.out.println(service.bulkRequest(<span class="string">&quot;desktop&quot;</span>,requests));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对多个索引中特定的字段进行关键字查找"><a href="#对多个索引中特定的字段进行关键字查找" class="headerlink" title="对多个索引中特定的字段进行关键字查找"></a>对多个索引中特定的字段进行关键字查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*要设置查找的字段也可以当成参数传递进来，懒得改了</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title">searchByKeyword</span><span class="params">(String keyword,String...indices)</span> </span>&#123;</span><br><span class="line">    List&lt;JSONObject&gt;results=<span class="keyword">null</span>;</span><br><span class="line">    SearchRequest request=<span class="keyword">new</span> SearchRequest();</span><br><span class="line">    request.indices(indices);</span><br><span class="line">    SearchSourceBuilder builder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//设置查找字段</span></span><br><span class="line">    builder.query(QueryBuilders.multiMatchQuery(keyword,<span class="string">&quot;programName&quot;</span>,<span class="string">&quot;tag&quot;</span>,<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                  .fuzziness(Fuzziness.AUTO));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    SearchResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">if</span>(hits.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        results=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(SearchHit hit:hits)&#123;</span><br><span class="line">            JSONObject jsonObject=JSONObject.parseObject(hit.getSourceAsString());</span><br><span class="line">            results.add(jsonObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用账号密码连接elasticsaerch"><a href="#使用账号密码连接elasticsaerch" class="headerlink" title="使用账号密码连接elasticsaerch"></a>使用账号密码连接elasticsaerch</h2><p>通常默认情况下es本地是不设账号密码的，可直接通过localhost:9200访问，但是也可以设置密码来加强es的安全性</p>
<h3 id="修改elasticsearch-yml配置文件"><a href="#修改elasticsearch-yml配置文件" class="headerlink" title="修改elasticsearch.yml配置文件"></a>修改elasticsearch.yml配置文件</h3><p>使用xpack给es添加安全支持，同时允许<code>http</code>请求跨域，在<code>elasticsearch.yml</code>文件中添加以下配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">Authorization</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="执行自定义密码的命令"><a href="#执行自定义密码的命令" class="headerlink" title="执行自定义密码的命令"></a>执行自定义密码的命令</h3><p>cd到es的<code>bin</code>目录下，执行<code>elasticsearch-setup-passwords interactive</code>，按照提示分别给几个系统都设置密码</p>
<h3 id="通过kibana或localhost-9200访问测试"><a href="#通过kibana或localhost-9200访问测试" class="headerlink" title="通过kibana或localhost:9200访问测试"></a>通过kibana或localhost:9200访问测试</h3><p>启动kibana/elasticsearch服务，在访问<code>lcalhost:5601/localhost:9200</code>时输入es账号密码，默认账号为<code>elastic</code></p>
<h3 id="修改密码的curl命令"><a href="#修改密码的curl命令" class="headerlink" title="修改密码的curl命令"></a>修改密码的curl命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_security&#x2F;user&#x2F;&#123;username&#125;&#x2F;_password</span><br><span class="line">&#123;</span><br><span class="line">  &quot;password&quot;: &quot;your password&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在Java中通过api连接"><a href="#在Java中通过api连接" class="headerlink" title="在Java中通过api连接"></a>在Java中通过api连接</h3><p>我们通常使用的是<code>RestHighLevelClient</code>，其可通过低级客户端的构造器<code>RestClientBuilder</code>获得，根据<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.14/_basic_authentication.html">官方文档</a>的指引，我们可通过设置http客户端的配置来设置账号密码最后构建<code>RestClientBuilder</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestClientBuilder <span class="title">restClientBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CredentialsProvider credentialsProvider =</span><br><span class="line">        <span class="keyword">new</span> BasicCredentialsProvider();</span><br><span class="line">    credentialsProvider.setCredentials(AuthScope.ANY,</span><br><span class="line">                                       <span class="keyword">new</span> UsernamePasswordCredentials(username, 	password));</span><br><span class="line">    RestClientBuilder builder=RestClient.builder(<span class="keyword">new</span> HttpHost(host,port,protocol));</span><br><span class="line">    builder.setHttpClientConfigCallback(<span class="keyword">new</span> RestClientBuilder.HttpClientConfigCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpAsyncClientBuilder <span class="title">customizeHttpClient</span><span class="params">(HttpAsyncClientBuilder httpAsyncClientBuilder)</span> </span>&#123;</span><br><span class="line">            httpAsyncClientBuilder.disableAuthCaching();</span><br><span class="line">            <span class="keyword">return</span> httpAsyncClientBuilder.setDefaultCredentialsProvider(credentialsProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;restHighLevelClient&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">(<span class="meta">@Autowired</span> RestClientBuilder restClientBuilder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(restClientBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>学习</tag>
        <tag>elasticsearch</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
